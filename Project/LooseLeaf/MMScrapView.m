//
//  MMScrap.m
//  LooseLeaf
//
//  Created by Adam Wulf on 8/23/13.
//  Copyright (c) 2013 Milestone Made, LLC. All rights reserved.
//

#import "MMScrapView.h"
#import "UIColor+ColorWithHex.h"
#import <CoreGraphics/CoreGraphics.h>
#import <QuartzCore/QuartzCore.h>
#import "MMRotationManager.h"
#import "DrawKit-iOS.h"
#import "UIColor+Shadow.h"
#import "MMDebugDrawView.h"
#import "NSString+UUID.h"
#import "NSThread+BlockAdditions.h"


#import <JotUI/AbstractBezierPathElement-Protected.h>

@implementation MMScrapView{
    // **
    // we'll need to save these properties to disk
    //
    // the path used to clip the scrap, includes buffer for shadow
    UIBezierPath* bezierPath;
    // the original size of the input path, this size represents scale of 1
    CGSize originalSize;
    // our drawable backing view
    JotView* drawableView;

    // **
    // these properties will be saved by the page that holds us, if any
    //
    // our current scale
    CGFloat scale;
    // our current rotation around our center
    CGFloat rotation;

    
    // these properties are UI only, and
    // don't need to be persisted
    
    // boolean to say if the user is currently holding this scrap. used for blue border
    BOOL selected;
    // the layer used for our white background. won't clip sub-content
    CAShapeLayer* contentLayer;

    
    // these properties are calculated, and
    // don't need to be persisted

    // this will track whenever a property of the scrap has changed,
    // so that we can recalculate the path to use when clipping strokes
    // around/through this scrap
    BOOL needsClippingPathUpdate;

    UIBezierPath* clippingPath;
    
    NSString* uuid;
    
    // the path where we store our data
    NSString* scrapPath;
    
    // the undoHash of the drawable view from
    // when it was last saved
    NSUInteger lastSavedUndoHash;
}

@synthesize uuid;
@synthesize scale;
@synthesize originalSize;
@synthesize rotation;
@synthesize selected;
@synthesize clippingPath;
@synthesize bezierPath;


-(id) initWithUUID:(NSString*)_uuid{
    NSString* pathForUUID = [MMScrapView scrapPathForUUID:_uuid];
    if([[NSFileManager defaultManager] fileExistsAtPath:pathForUUID]){
        NSString* plistPath = [pathForUUID stringByAppendingPathComponent:[@"info" stringByAppendingPathExtension:@"plist"]];
        NSDictionary* properties = [NSDictionary dictionaryWithContentsOfFile:plistPath];
        
        UIBezierPath *path = [NSKeyedUnarchiver unarchiveObjectWithData:[properties objectForKey:@"bezierPath"]];

        if(self = [self initWithBezierPath:path andUUID:_uuid]){
            // load drawable view information here
            
            NSString* inkImageFile = [pathForUUID stringByAppendingPathComponent:[@"ink" stringByAppendingPathExtension:@"png"]];
            NSString* stateFile = [pathForUUID stringByAppendingPathComponent:[@"state" stringByAppendingPathExtension:@"plist"]];
            JotViewState* state = [[JotViewState alloc] initWithImageFile:inkImageFile
                                                             andStateFile:stateFile
                                                              andPageSize:[drawableView pagePixelSize]
                                                             andGLContext:[drawableView context]];
            [drawableView loadState:state];
            
            lastSavedUndoHash = [drawableView undoHash];
        }
    }
    return self;
}

- (id)initWithBezierPath:(UIBezierPath *)path{
    return [self initWithBezierPath:path andUUID:[NSString createStringUUID]];
}

/**
 * this input path is in CoreGraphics coordinate space. it's been generated by all of the touch
 * points, and then fed through TouchShape to generate a SYShape, which has generated this input path
 */
- (id)initWithBezierPath:(UIBezierPath*)_path andUUID:(NSString*)_uuid
{
    _path = [_path copy];
    CGRect originalBounds = _path.bounds;
    [_path applyTransform:CGAffineTransformMakeTranslation(-originalBounds.origin.x + 4, -originalBounds.origin.y + 4)];

    // -4 b/c twice the 2px shadow
    if ((self = [super initWithFrame:CGRectInset(originalBounds, -4, -4)])) {
        uuid = _uuid;
        scale = 1;
        // Initialization code
        bezierPath = _path;
        originalSize = originalBounds.size;
        
        drawableView = [[JotView alloc] initWithFrame:self.bounds];
        
        contentLayer = [CAShapeLayer layer];
        [contentLayer setPath:bezierPath.CGPath];
        contentLayer.fillColor = [UIColor whiteColor].CGColor;
        contentLayer.masksToBounds = YES;
        contentLayer.frame = self.layer.bounds;
        [self.layer addSublayer:contentLayer];
        
        
//        CALayer* fakeContent = [CALayer layer];
//        fakeContent.frame = CGRectMake(0, 0, 500, 100);
//        fakeContent.backgroundColor = [UIColor redColor].CGColor;
//        [contentLayer addSublayer:fakeContent];
        
        
        self.layer.shadowPath = bezierPath.CGPath;
        self.layer.shadowRadius = 1.5;
        self.layer.shadowColor = [[UIColor blackColor] colorWithAlphaComponent:.5].CGColor;
        self.layer.shadowOpacity = .65;
        self.layer.shadowOffset = CGSizeMake(0, 0);
        
        self.opaque = NO;
        self.clipsToBounds = YES;
        [self didUpdateAccelerometerWithRawReading:[[MMRotationManager sharedInstace] currentRawRotationReading]];
        needsClippingPathUpdate = YES;
        
        [self addSubview:drawableView];

        [MMDebugDrawView sharedInstace].frame = self.bounds;
        [self addSubview:[MMDebugDrawView sharedInstace]];

        lastSavedUndoHash = -1;
    }
    return self;
}

-(void) setSelected:(BOOL)_selected{
    selected = _selected;
    if(selected){
        self.layer.shadowColor = [[UIColor blueShadowColor] colorWithAlphaComponent:1].CGColor;
        self.layer.shadowRadius = 2.5;
    }else{
        self.layer.shadowRadius = 1.5;
        self.layer.shadowColor = [[UIColor blackColor] colorWithAlphaComponent:.5].CGColor;
    }
}

-(void) setBackgroundColor:(UIColor *)backgroundColor{
    contentLayer.fillColor = backgroundColor.CGColor;
}

/**
 * scraps will show the shadow move ever so slightly as the device is turned
 */
-(void) didUpdateAccelerometerWithRawReading:(CGFloat)currentRawReading{
    self.layer.shadowOffset = CGSizeMake(cosf(currentRawReading)*1, sinf(currentRawReading)*1);
}

#pragma mark - UITouch Helper methods

/**
 * these methods are used from inside of gestures to help
 * determine when touches begin/move/etc inide of a scrap
 */

-(BOOL) containsTouch:(UITouch*)touch{
    CGPoint locationOfTouch = [touch locationInView:self];
    return [bezierPath containsPoint:locationOfTouch];
}

-(NSSet*) matchingPairTouchesFrom:(NSSet*) touches{
    NSSet* outArray = [self allMatchingTouchesFrom:touches];
    if([outArray count] >= 2){
        return outArray;
    }
    return nil;
}

-(NSSet*) allMatchingTouchesFrom:(NSSet*) touches{
    NSMutableSet* outArray = [NSMutableSet set];
    for(UITouch* touch in touches){
        if([self containsTouch:touch]){
            [outArray addObject:touch];
        }
    }
    return outArray;
}

#pragma mark - Postion, Scale, Rotation

-(void) setScale:(CGFloat)_scale andRotation:(CGFloat)_rotation{
//    if(_scale > 2) _scale = 2;
//    if(_scale * self.bounds.size.width < 100){
//        _scale = 100 / self.bounds.size.width;
//    }
//    if(_scale * self.bounds.size.height < 100){
//        _scale = 100 / self.bounds.size.height;
//    }
    scale = _scale;
    rotation = _rotation;
    needsClippingPathUpdate = YES;
    self.transform = CGAffineTransformConcat(CGAffineTransformMakeRotation(rotation),CGAffineTransformMakeScale(scale, scale));
}

-(void) setScale:(CGFloat)_scale{
    [self setScale:_scale andRotation:self.rotation];
}

-(void) setRotation:(CGFloat)_rotation{
    [self setScale:self.scale andRotation:_rotation];
}

-(void) setFrame:(CGRect)frame{
    [super setFrame:frame];
    needsClippingPathUpdate = YES;
}

-(void) setBounds:(CGRect)bounds{
    [super setBounds:bounds];
    needsClippingPathUpdate = YES;
}

-(void) setCenter:(CGPoint)center{
    [super setCenter:center];
    needsClippingPathUpdate = YES;
}


#pragma mark - Clipping Path

/**
 * we'll cache our clipping path since it
 * takes a bit of processing power to
 * calculate.
 *
 * this will always return the correct clipping
 * path, and will recalculate and update our
 * cache if need be
 */
-(UIBezierPath*) clippingPath{
    if(needsClippingPathUpdate){
        [self commitEditsAndUpdateClippingPath];
        needsClippingPathUpdate = NO;
    }
    return clippingPath;
}

/**
 * our clippingPath is in OpenGL coordinate space, just
 * as all of the CurveToPathElements that we use for
 * drawing. This will transform our CoreGraphics coordinated
 * bezierPath into OpenGL including our location, rotation,
 * and scale so that we can clip all of the CurveToPathElements
 * with this path to help determine which parts of the drawn
 * line should be added to this scrap.
 */
-(void) commitEditsAndUpdateClippingPath{
    // start with our original path
    clippingPath = [self.bezierPath copy];
    
    // when we pick up a scrap with a two finger gesture, we also
    // change the position and anchor (which change the center), so
    // that it rotates underneath the gesture correctly.
    //
    // we need to re-caculate the true center of the scrap as if it
    // was not being held, so that we can position our path correctly
    // over it.
    CGPoint actualScrapCenter = CGPointMake( CGRectGetMidX(self.frame), CGRectGetMidY(self.frame));
    CGPoint clippingPathCenter = clippingPath.center;
    
    // first, align the center of the scrap to the center of the path
    CGAffineTransform reCenterTransform = CGAffineTransformMakeTranslation(actualScrapCenter.x - clippingPathCenter.x, actualScrapCenter.y - clippingPathCenter.y);
    clippingPathCenter = CGPointApplyAffineTransform(clippingPathCenter, reCenterTransform);
    
    
    // now we need to rotate the path around it's new center
    CGAffineTransform moveFromCenter = CGAffineTransformMakeTranslation(-clippingPathCenter.x, -clippingPathCenter.y);
    CGAffineTransform rotateAndScale = CGAffineTransformConcat(CGAffineTransformMakeRotation(self.rotation),CGAffineTransformMakeScale(self.scale, self.scale));
    CGAffineTransform moveToCenter = CGAffineTransformMakeTranslation(clippingPathCenter.x, clippingPathCenter.y);
    
    CGAffineTransform flipTransform = CGAffineTransformMake(1, 0, 0, -1, 0, self.superview.bounds.size.height);
    
    CGAffineTransform clippingPathTransform = reCenterTransform;
    clippingPathTransform = CGAffineTransformConcat(clippingPathTransform, moveFromCenter);
    clippingPathTransform = CGAffineTransformConcat(clippingPathTransform, rotateAndScale);
    clippingPathTransform = CGAffineTransformConcat(clippingPathTransform, moveToCenter);
    clippingPathTransform = CGAffineTransformConcat(clippingPathTransform, flipTransform);
    
    [clippingPath applyTransform:clippingPathTransform];
}



#pragma mark - JotView

-(void) addElement:(AbstractBezierPathElement *)element{
    [drawableView addElement:element];
}


#pragma mark - Ignore Touches

/**
 * these two methods make sure that the ruler view
 * can never intercept any touch input. instead it will
 * effectively pass through this view to the views behind it
 */
-(UIView*) hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    return nil;
}

-(BOOL) pointInside:(CGPoint)point withEvent:(UIEvent *)event{
    return NO;
}


#pragma mark - Saving

+(NSString*) scrapPathForUUID:(NSString*)uuid{
    NSArray* paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString* documentsPath = [paths objectAtIndex:0];
    NSString* scrapPath = [[documentsPath stringByAppendingPathComponent:@"Scraps"] stringByAppendingPathComponent:uuid];
    return scrapPath;
}



-(NSString*) scrapPath{
    if(!scrapPath){
        scrapPath = [MMScrapView scrapPathForUUID:[self uuid]];
        if(![[NSFileManager defaultManager] fileExistsAtPath:scrapPath]){
            [[NSFileManager defaultManager] createDirectoryAtPath:scrapPath withIntermediateDirectories:YES attributes:nil error:nil];
        }
    }
    return scrapPath;
}

-(void) saveToDisk{
    if(lastSavedUndoHash != [drawableView undoHash]){
        NSString* plistPath = [self.scrapPath stringByAppendingPathComponent:[@"info" stringByAppendingPathExtension:@"plist"]];
        NSString* pathForUUID = [MMScrapView scrapPathForUUID:self.uuid];
        NSString* inkImageFile = [pathForUUID stringByAppendingPathComponent:[@"ink" stringByAppendingPathExtension:@"png"]];
        NSString* thumbImageFile = [pathForUUID stringByAppendingPathComponent:[@"thumb" stringByAppendingPathExtension:@"png"]];
        NSString* stateFile = [pathForUUID stringByAppendingPathComponent:[@"state" stringByAppendingPathExtension:@"plist"]];
        
        dispatch_semaphore_t sema1 = dispatch_semaphore_create(0);
        [NSThread performBlockOnMainThread:^{
            // save path
            // this needs to be saved at the exact same time as the drawable view
            // so that we can guarentee that there is no race condition
            // for saving state vs content
            NSMutableDictionary* savedProperties = [NSMutableDictionary dictionary];
            [savedProperties setObject:[NSKeyedArchiver archivedDataWithRootObject:bezierPath] forKey:@"bezierPath"];
            [savedProperties writeToFile:plistPath atomically:YES];

            // now export the drawn content
            [drawableView exportImageTo:inkImageFile andThumbnailTo:thumbImageFile andStateTo:stateFile onComplete:^(UIImage* ink, UIImage* thumb, JotViewImmutableState* state){
                dispatch_semaphore_signal(sema1);
                lastSavedUndoHash = [state undoHash];
            }];
        }];
        dispatch_semaphore_wait(sema1, DISPATCH_TIME_FOREVER);
    }
}

#pragma mark - Debug


/**
 * draws a large boxed "X" on the scrap to show it's bounds and location
 */
-(void) drawX{
    
    UIColor* color = [UIColor randomColor];
    
    CurveToPathElement* curveTo = [CurveToPathElement elementWithStart:CGPointMake(10, 10)
                                                             andLineTo:CGPointMake(self.bounds.size.width-10, 10)];
    curveTo.width = 10;
    curveTo.color = color;
    curveTo.rotation = 0;
    [drawableView addElement:curveTo];
    
    curveTo = [CurveToPathElement elementWithStart:CGPointMake(self.bounds.size.width-10, 10)
                                         andLineTo:CGPointMake(self.bounds.size.width-10, self.bounds.size.height - 10)];
    curveTo.width = 10;
    curveTo.color = color;
    curveTo.rotation = 0;
    [drawableView addElement:curveTo];
    
    curveTo = [CurveToPathElement elementWithStart:CGPointMake(self.bounds.size.width-10, self.bounds.size.height - 10)
                                         andLineTo:CGPointMake(10, self.bounds.size.height - 10)];
    curveTo.width = 10;
    curveTo.color = color;
    curveTo.rotation = 0;
    [drawableView addElement:curveTo];
    
    curveTo = [CurveToPathElement elementWithStart:CGPointMake(10, self.bounds.size.height - 10)
                                         andLineTo:CGPointMake(10, 10)];
    curveTo.width = 10;
    curveTo.color = color;
    curveTo.rotation = 0;
    [drawableView addElement:curveTo];
    
    curveTo = [CurveToPathElement elementWithStart:CGPointMake(10, 10)
                                         andLineTo:CGPointMake(self.bounds.size.width-10, self.bounds.size.height - 10)];
    curveTo.width = 10;
    curveTo.color = color;
    curveTo.rotation = 0;
    [drawableView addElement:curveTo];
    
    curveTo = [CurveToPathElement elementWithStart:CGPointMake(10, self.bounds.size.height - 10)
                                         andLineTo:CGPointMake(self.bounds.size.width - 10, 10)];
    curveTo.width = 10;
    curveTo.color = color;
    curveTo.rotation = 0;
    [drawableView addElement:curveTo];
}


@end
